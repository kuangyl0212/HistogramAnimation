<html>
<head>
<title>StdDraw.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080; font-style: italic;}
.s1 { color: #000000;}
.s2 { color: #000080; font-weight: bold;}
.s3 { color: #808080; font-weight: bold; font-style: italic;}
.s4 { color: #808080; font-style: italic;}
.s5 { color: #0000ff;}
.s6 { color: #008000; font-weight: bold;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
StdDraw.java</font>
</center></td></tr></table>
<pre><span class="s0">/******************************************************************************</span>
 *  Compilation:  javac StdDraw.java
 *  Execution:    java StdDraw
 *  Dependencies: none
 *
 *  Standard drawing library. This class provides a basic capability for
 *  creating drawings with your programs. It uses a simple graphics model that
 *  allows you to create drawings consisting of points, lines, and curves
 *  in a window on your computer and to save the drawings to a file.
 *
 *  Todo
 *  ----
 *    -  Add support for gradient fill, etc.
 *    -  Fix setCanvasSize() so that it can only be called once.
 *    -  On some systems, drawing a line (or other shape) that extends way
 *       beyond canvas (e.g., to infinity) dimensions does not get drawn.
 *
 *  Remarks
 *  -------
 *    -  don't use AffineTransform for rescaling since it inverts
 *       images and strings
 *
 ******************************************************************************/

<span class="s2">import </span>java.awt.BasicStroke;
<span class="s2">import </span>java.awt.Color;
<span class="s2">import </span>java.awt.FileDialog;
<span class="s2">import </span>java.awt.Font;
<span class="s2">import </span>java.awt.FontMetrics;
<span class="s2">import </span>java.awt.Graphics2D;
<span class="s2">import </span>java.awt.Image;
<span class="s2">import </span>java.awt.MediaTracker;
<span class="s2">import </span>java.awt.RenderingHints;
<span class="s2">import </span>java.awt.Toolkit;

<span class="s2">import </span>java.awt.event.ActionEvent;
<span class="s2">import </span>java.awt.event.ActionListener;
<span class="s2">import </span>java.awt.event.MouseEvent;
<span class="s2">import </span>java.awt.event.MouseListener;
<span class="s2">import </span>java.awt.event.MouseMotionListener;
<span class="s2">import </span>java.awt.event.KeyEvent;
<span class="s2">import </span>java.awt.event.KeyListener;

<span class="s2">import </span>java.awt.geom.Arc2D;
<span class="s2">import </span>java.awt.geom.Ellipse2D;
<span class="s2">import </span>java.awt.geom.GeneralPath;
<span class="s2">import </span>java.awt.geom.Line2D;
<span class="s2">import </span>java.awt.geom.Rectangle2D;

<span class="s2">import </span>java.awt.image.BufferedImage;
<span class="s2">import </span>java.awt.image.DirectColorModel;
<span class="s2">import </span>java.awt.image.WritableRaster;

<span class="s2">import </span>java.io.File;
<span class="s2">import </span>java.io.IOException;

<span class="s2">import </span>java.net.MalformedURLException;
<span class="s2">import </span>java.net.URL;

<span class="s2">import </span>java.util.LinkedList;
<span class="s2">import </span>java.util.TreeSet;
<span class="s2">import </span>java.util.NoSuchElementException;
<span class="s2">import </span>javax.imageio.ImageIO;

<span class="s2">import </span>javax.swing.ImageIcon;
<span class="s2">import </span>javax.swing.JFrame;
<span class="s2">import </span>javax.swing.JLabel;
<span class="s2">import </span>javax.swing.JMenu;
<span class="s2">import </span>javax.swing.JMenuBar;
<span class="s2">import </span>javax.swing.JMenuItem;
<span class="s2">import </span>javax.swing.KeyStroke;

<span class="s0">/**</span>
 *  The {<span class="s3">@code </span><span class="s0">StdDraw} class provides a basic capability for</span>
 *  creating drawings with your programs. It uses a simple graphics model that
 *  allows you to create drawings consisting of points, lines, squares, 
 *  circles, and other geometric shapes in a window on your computer and
 *  to save the drawings to a file. Standard drawing also includes
 *  facilities for text, color, pictures, and animation, along with
 *  user interaction via the keyboard and mouse.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Getting started.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  To use standard drawing, you must have {</span><span class="s3">@code </span><span class="s0">StdDraw.class} in your</span>
 *  Java classpath. If you used our autoinstaller, you should be all set.
 *  Otherwise, download
 *  <span class="s4">&lt;a href = &quot;https://introcs.cs.princeton.edu/java/stdlib/StdDraw.java&quot;&gt;</span><span class="s0">StdDraw.java</span><span class="s4">&lt;/a&gt;</span>
 <span class="s0">*  and put a copy in your working directory.</span>
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  Now, type the following short program into your editor:</span>
 *  <span class="s4">&lt;pre&gt;</span>
 <span class="s0">*   public class TestStdDraw {</span>
 *       public static void main(String[] args) {
 *           StdDraw.setPenRadius(0.05);
 *           StdDraw.setPenColor(StdDraw.BLUE);
 *           StdDraw.point(0.5, 0.5);
 *           StdDraw.setPenColor(StdDraw.MAGENTA);
 *           StdDraw.line(0.2, 0.2, 0.8, 0.2);
 *       }
 *   }
 *  <span class="s4">&lt;/pre&gt;</span>
 <span class="s0">*  If you compile and execute the program, you should see a window</span>
 *  appear with a thick magenta line and a blue point.
 *  This program illustrates the two main types of methods in standard
 *  drawing—methods that draw geometric shapes and methods that
 *  control drawing parameters.
 *  The methods {<span class="s3">@code </span><span class="s0">StdDraw.line()} and {</span><span class="s3">@code </span><span class="s0">StdDraw.point()}</span>
 *  draw lines and points; the methods {<span class="s3">@code </span><span class="s0">StdDraw.setPenRadius()}</span>
 *  and {<span class="s3">@code </span><span class="s0">StdDraw.setPenColor()} control the line thickness and color.</span>
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Points and lines.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can draw points and line segments with the following methods:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#point(double x, double y)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#line(double x1, double y1, double x2, double y2)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates must be in the drawing area</span>
 *  (between 0 and 1 and by default) or the points and lines will not be visible.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Squares, circles, rectangles, and ellipses.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can draw squares, circles, rectangles, and ellipses using</span>
 *  the following methods:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#circle(double x, double y, double radius)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#ellipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#square(double x, double y, double radius)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#rectangle(double x, double y, double halfWidth, double halfHeight)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  All of these methods take as arguments the location and size of the shape.</span>
 *  The location is always specified by the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates</span>
 *  of its <span class="s4">&lt;em&gt;</span><span class="s0">center</span><span class="s4">&lt;/em&gt;</span><span class="s0">.</span>
 *  The size of a circle is specified by its radius and the size of an ellipse is
 *  specified by the lengths of its semi-major and semi-minor axes.
 *  The size of a square or rectangle is specified by its half-width or half-height.
 *  The convention for drawing squares and rectangles is parallel to those for
 *  drawing circles and ellipses, but may be unexpected to the uninitiated.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The methods above trace outlines of the given shapes. The following methods</span>
 *  draw filled versions:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#filledCircle(double x, double y, double radius)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#filledEllipse(double x, double y, double semiMajorAxis, double semiMinorAxis)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#filledSquare(double x, double y, double radius)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#filledRectangle(double x, double y, double halfWidth, double halfHeight)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Circular arcs.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can draw circular arcs with the following method:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#arc(double x, double y, double radius, double angle1, double angle2)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The arc is from the circle centered at (</span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">) of the specified radius.</span>
 *  The arc extends from angle1 to angle2. By convention, the angles are
 *  <span class="s4">&lt;em&gt;</span><span class="s0">polar</span><span class="s4">&lt;/em&gt; </span><span class="s0">(counterclockwise angle from the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-axis)</span>
 *  and represented in degrees. For example, {<span class="s3">@code </span><span class="s0">StdDraw.arc(0.0, 0.0, 1.0, 0, 90)}</span>
 *  draws the arc of the unit circle from 3 o'clock (0 degrees) to 12 o'clock (90 degrees).
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Polygons.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can draw polygons with the following methods:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#polygon(double[] x, double[] y)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#filledPolygon(double[] x, double[] y)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The points in the polygon are ({</span><span class="s3">@code </span><span class="s0">x[i]}, {</span><span class="s3">@code </span><span class="s0">y[i]}).</span>
 *  For example, the following code fragment draws a filled diamond
 *  with vertices (0.1, 0.2), (0.2, 0.3), (0.3, 0.2), and (0.2, 0.1):
 *  <span class="s4">&lt;pre&gt;</span>
 <span class="s0">*   double[] x = { 0.1, 0.2, 0.3, 0.2 };</span>
 *   double[] y = { 0.2, 0.3, 0.2, 0.1 };
 *   StdDraw.filledPolygon(x, y);
 *  <span class="s4">&lt;/pre&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Pen size.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  The pen is circular, so that when you set the pen radius to </span><span class="s4">&lt;em&gt;</span><span class="s0">r</span><span class="s4">&lt;/em&gt;</span>
 <span class="s0">*  and draw a point, you get a circle of radius </span><span class="s4">&lt;em&gt;</span><span class="s0">r</span><span class="s4">&lt;/em&gt;</span><span class="s0">. Also, lines are</span>
 *  of thickness 2<span class="s4">&lt;em&gt;</span><span class="s0">r</span><span class="s4">&lt;/em&gt; </span><span class="s0">and have rounded ends. The default pen radius</span>
 *  is 0.005 and is not affected by coordinate scaling. This default pen
 *  radius is about 1/200 the width of the default canvas, so that if
 *  you draw 100 points equally spaced along a horizontal or vertical line,
 *  you will be able to see individual circles, but if you draw 200 such
 *  points, the result will look like a line.
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setPenRadius(double radius)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  For example, {</span><span class="s3">@code </span><span class="s0">StdDraw.setPenRadius(0.025)} makes</span>
 *  the thickness of the lines and the size of the points to be five times
 *  the 0.005 default.
 *  To draw points with the minimum possible radius (one pixel on typical
 *  displays), set the pen radius to 0.0.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Pen color.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  All geometric shapes (such as points, lines, and circles) are drawn using</span>
 *  the items pen color. By default, it is black.
 *  You can change the pen color with the following methods:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setPenColor(int red, int green, int blue)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setPenColor(Color color)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The first method allows you to specify colors using the RGB color system.</span>
 *  This <span class="s4">&lt;a href = &quot;http://johndyer.name/lab/colorpicker/&quot;&gt;</span><span class="s0">color picker</span><span class="s4">&lt;/a&gt;</span>
 <span class="s0">*  is a convenient way to find a desired color.</span>
 *  The second method allows you to specify colors using the
 *  {<span class="s3">@link </span><span class="s0">Color} data type that is discussed in Chapter 3. Until then,</span>
 *  you can use this method with one of these predefined colors in standard drawing:
 *  {<span class="s3">@link </span><span class="s0">#BLACK}, {</span><span class="s3">@link </span><span class="s0">#BLUE}, {</span><span class="s3">@link </span><span class="s0">#CYAN}, {</span><span class="s3">@link </span><span class="s0">#DARK_GRAY}, {</span><span class="s3">@link </span><span class="s0">#GRAY},</span>
 *  {<span class="s3">@link </span><span class="s0">#GREEN}, {</span><span class="s3">@link </span><span class="s0">#LIGHT_GRAY}, {</span><span class="s3">@link </span><span class="s0">#MAGENTA}, {</span><span class="s3">@link </span><span class="s0">#ORANGE},</span>
 *  {<span class="s3">@link </span><span class="s0">#PINK}, {</span><span class="s3">@link </span><span class="s0">#RED}, {</span><span class="s3">@link </span><span class="s0">#WHITE}, {</span><span class="s3">@link </span><span class="s0">#YELLOW},</span>
 *  {<span class="s3">@link </span><span class="s0">#BOOK_BLUE}, {</span><span class="s3">@link </span><span class="s0">#BOOK_LIGHT_BLUE}, {</span><span class="s3">@link </span><span class="s0">#BOOK_RED}, and</span>
 *  {<span class="s3">@link </span><span class="s0">#PRINCETON_ORANGE}.</span>
 *  For example, {<span class="s3">@code </span><span class="s0">StdDraw.setPenColor(StdDraw.MAGENTA)} sets the</span>
 *  pen color to magenta.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Canvas size.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  By default, all drawing takes places in a 512-by-512 canvas.</span>
 *  The canvas does not include the window title or window border.
 *  You can change the size of the canvas with the following method:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setCanvasSize(int width, int height)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  This sets the canvas size to be </span><span class="s4">&lt;em&gt;</span><span class="s0">width</span><span class="s4">&lt;/em&gt;</span><span class="s0">-by-</span><span class="s4">&lt;em&gt;</span><span class="s0">height</span><span class="s4">&lt;/em&gt; </span><span class="s0">pixels.</span>
 *  It also erases the items drawing and resets the coordinate system,
 *  pen radius, pen color, and font back to their default values.
 *  Ordinarly, this method is called once, at the very beginning of a program.
 *  For example, {<span class="s3">@code </span><span class="s0">StdDraw.setCanvasSize(800, 800)}</span>
 *  sets the canvas size to be 800-by-800 pixels.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Canvas scale and coordinate system.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  By default, all drawing takes places in the unit square, with (0, 0) at</span>
 *  lower left and (1, 1) at upper right. You can change the default
 *  coordinate system with the following methods:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setXscale(double xmin, double xmax)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setYscale(double ymin, double ymax)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setScale(double min, double max)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The arguments are the coordinates of the minimum and maximum </span>
 *  <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- or </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates that will appear in the canvas.</span>
 *  For example, if you  wish to use the default coordinate system but
 *  leave a small margin, you can call {<span class="s3">@code </span><span class="s0">StdDraw.setScale(-.05, 1.05)}.</span>
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  These methods change the coordinate system for subsequent drawing</span>
 *  commands; they do not affect previous drawings.
 *  These methods do not change the canvas size; so, if the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-</span>
 *  and <span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scales are different, squares will become rectangles</span>
 *  and circles will become ellipsoidal.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Text.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can use the following methods to annotate your drawings with text:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#text(double x, double y, String text)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#text(double x, double y, String text, double degrees)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#textLeft(double x, double y, String text)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#textRight(double x, double y, String text)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The first two methods write the specified text in the items font,</span>
 *  centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
 *  The second method allows you to rotate the text.
 *  The last two methods either left- or right-align the text at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The default font is a Sans Serif font with point size 16.</span>
 *  You can use the following method to change the font:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#setFont(Font font)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  You use the {</span><span class="s3">@link </span><span class="s0">Font} data type to specify the font. This allows you to</span>
 *  choose the face, size, and style of the font. For example, the following
 *  code fragment sets the font to Arial Bold, 60 point.
 *  <span class="s4">&lt;pre&gt;</span>
 <span class="s0">*   Font font = new Font(&quot;Arial&quot;, Font.BOLD, 60);</span>
 *   StdDraw.setFont(font);
 *   StdDraw.text(0.5, 0.5, &quot;Hello, World&quot;);
 *  <span class="s4">&lt;/pre&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Images.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can use the following methods to add images to your drawings:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#picture(double x, double y, String filename)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#picture(double x, double y, String filename, double degrees)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#picture(double x, double y, String filename, double scaledWidth, double scaledHeight)}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#picture(double x, double y, String filename, double scaledWidth, double scaledHeight, double degrees)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  These methods draw the specified image, centered at (</span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
 *  The supported image formats are JPEG, PNG, and GIF.
 *  The image will display at its native size, independent of the coordinate system.
 *  Optionally, you can rotate the image a specified number of degrees counterclockwise
 *  or rescale it to fit snugly inside a width-by-height bounding box.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Saving to a file.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You save your image to a file using the </span><span class="s4">&lt;em&gt;</span><span class="s0">File _ Save</span><span class="s4">&lt;/em&gt; </span><span class="s0">menu option.</span>
 *  You can also save a file programatically using the following method:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#save(String filename)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The supported image formats are JPEG and PNG. The filename must have either the</span>
 *  extension .jpg or .png.
 *  We recommend using PNG for drawing that consist solely of geometric shapes and JPEG 
 *  for drawings that contains pictures.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Clearing the canvas.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  To clear the entire drawing canvas, you can use the following methods:</span>
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#clear()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#clear(Color color)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The first method clears the canvas to white; the second method</span>
 *  allows you to specify a color of your choice. For example,
 *  {<span class="s3">@code </span><span class="s0">StdDraw.clear(StdDraw.LIGHT_GRAY)} clears the canvas to a shade</span>
 *  of gray.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Computer animations and double buffering.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  Double buffering is one of the most powerful features of standard drawing,</span>
 *  enabling computer animations.
 *  The following methods control the way in which objects are drawn:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#enableDoubleBuffering()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#disableDoubleBuffering()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#show()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#pause(int t)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  By default, double buffering is disabled, which means that as soon as you</span>
 *  call a drawing
 *  method—such as {<span class="s3">@code </span><span class="s0">point()} or {</span><span class="s3">@code </span><span class="s0">line()}—the</span>
 *  results appear on the screen.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  When double buffering is enabled by calling {</span><span class="s3">@link </span><span class="s0">#enableDoubleBuffering()},</span>
 *  all drawing takes place on the <span class="s4">&lt;em&gt;</span><span class="s0">offscreen canvas</span><span class="s4">&lt;/em&gt;</span><span class="s0">. The offscreen canvas</span>
 *  is not displayed. Only when you call
 *  {<span class="s3">@link </span><span class="s0">#show()} does your drawing get copied from the offscreen canvas to</span>
 *  the onscreen canvas, where it is displayed in the standard drawing window. You 
 *  can think of double buffering as collecting all of the lines, points, shapes,
 *  and text that you tell it to draw, and then drawing them all
 *  <span class="s4">&lt;em&gt;</span><span class="s0">simultaneously</span><span class="s4">&lt;/em&gt;</span><span class="s0">, upon request.</span>
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The most important use of double buffering is to produce computer</span>
 *  animations, creating the illusion of motion by rapidly
 *  displaying static drawings. To produce an animation, repeat
 *  the following four steps:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">Clear the offscreen canvas.</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Draw objects on the offscreen canvas.</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Copy the offscreen canvas to the onscreen canvas.</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Wait for a short while.</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The {</span><span class="s3">@link </span><span class="s0">#clear()}, {</span><span class="s3">@link </span><span class="s0">#show()}, and {</span><span class="s3">@link </span><span class="s0">#pause(int t)} methods</span>
 *  support the first, third, and fourth of these steps, respectively.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  For example, this code fragment animates two balls moving in a circle.</span>
 *  <span class="s4">&lt;pre&gt;</span>
 <span class="s0">*   StdDraw.setScale(-2, +2);</span>
 *   StdDraw.enableDoubleBuffering();
 *
 *   for (double t = 0.0; true; t += 0.02) {
 *       double x = Math.sin(t);
 *       double y = Math.cos(t);
 *       StdDraw.clear();
 *       StdDraw.filledCircle(x, y, 0.05);
 *       StdDraw.filledCircle(-x, -y, 0.05);
 *       StdDraw.show();
 *       StdDraw.pause(20);
 *   }
 *  <span class="s4">&lt;/pre&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Keyboard and mouse inputs.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  Standard drawing has very basic support for keyboard and mouse input.</span>
 *  It is much less powerful than most user interface libraries provide, but also much simpler.
 *  You can use the following methods to intercept mouse events:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#isMousePressed()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#mouseX()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#mouseY()}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  The first method tells you whether a mouse button is currently being pressed.</span>
 *  The last two methods tells you the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates of the mouse's</span>
 *  items position, using the same coordinate system as the canvas (the unit square, by default).
 *  You should use these methods in an animation loop that waits a short while before trying
 *  to poll the mouse for its items state.
 *  You can use the following methods to intercept keyboard events:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#hasNextKeyTyped()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#nextKeyTyped()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#isKeyPressed(int keycode)}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  If the user types lots of steps, they will be saved in a list until you process them.</span>
 *  The first method tells you whether the user has typed a key (that your program has
 *  not yet processed).
 *  The second method returns the next key that the user typed (that your program has
 *  not yet processed) and removes it from the list of saved keystrokes.
 *  The third method tells you whether a key is currently being pressed.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Accessing control parameters.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  You can use the following methods to access the items pen color, pen radius,</span>
 *  and font:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#getPenColor()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#getPenRadius()}</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">{</span><span class="s3">@link </span><span class="s0">#getFont()}</span>
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  These methods are useful when you want to temporarily change a</span>
 *  control parameter and reset it back to its original value.
 *  <span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Corner cases.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  To avoid clutter, the API doesn't explicitly refer to arguments that are</span>
 *  null, infinity, or NaN.
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">Any method that is passed a {</span><span class="s3">@code </span><span class="s0">null} argument will throw an</span>
 *       {<span class="s3">@link </span><span class="s0">IllegalArgumentException}.</span>
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Except as noted in the APIs, drawing an object outside (or partly outside)</span>
 *       the canvas is permitted—however, only the part of the object that
 *       appears inside the canvas will be visible.
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Except as noted in the APIs, all methods accept {</span><span class="s3">@link </span><span class="s0">Double#NaN},</span>
 *       {<span class="s3">@link </span><span class="s0">Double#POSITIVE_INFINITY}, and {</span><span class="s3">@link </span><span class="s0">Double#NEGATIVE_INFINITY}</span>
 *       as arugments. An object drawn with an <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- or </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate</span>
 *       that is NaN will behave as if it is outside the canvas, and will not be visible.
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Due to floating-point issues, an object drawn with an </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- or</span>
 *       <span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate that is way outside the canvas (such as the line segment</span>
 *       from (0.5, –<span class="s4">&amp;infin;</span><span class="s0">) to (0.5, </span><span class="s4">&amp;infin;</span><span class="s0">) may not be visible even in the</span>
 *       part of the canvas where it should be.
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Performance tricks.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  Standard drawing is capable of drawing large amounts of data.</span>
 *  Here are a few tricks and tips:
 *  <span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">Use </span><span class="s4">&lt;em&gt;</span><span class="s0">double buffering</span><span class="s4">&lt;/em&gt; </span><span class="s0">for static drawing with a large</span>
 *       number of objects.
 *       That is, call {<span class="s3">@link </span><span class="s0">#enableDoubleBuffering()} before</span>
 *       the sequence of drawing commands and call {<span class="s3">@link </span><span class="s0">#show()} afterwards.</span>
 *       Incrementally displaying a complex drawing while it is being
 *       created can be intolerably inefficient on many computer systems.
 *  <span class="s4">&lt;li&gt; </span><span class="s0">When drawing computer animations, call {</span><span class="s3">@code </span><span class="s0">show()}</span>
 *       only once per frame, not after drawing each individual object.
 *  <span class="s4">&lt;li&gt; </span><span class="s0">If you call {</span><span class="s3">@code </span><span class="s0">picture()} multiple times with the same filename,</span>
 *       Java will cache the image, so you do not incur the cost of reading
 *       from a file each time.
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Known bugs and issues.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;li&gt; </span><span class="s0">The {</span><span class="s3">@code </span><span class="s0">picture()} methods may not draw the portion of the image that is</span>
 *       inside the canvas if the center point (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">) is outside the</span>
 *       canvas.
 *       This bug appears only on some systems.
 *  <span class="s4">&lt;li&gt; </span><span class="s0">Some methods may not draw the portion of the geometric object that is inside the</span>
 *       canvas if the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- or </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates are infinite.</span>
 *       This bug appears only on some systems.
 *  <span class="s4">&lt;/ul&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;p&gt;</span>
 <span class="s0">*  </span><span class="s4">&lt;b&gt;</span><span class="s0">Reference.</span><span class="s4">&lt;/b&gt;</span>
 <span class="s0">*  For additional documentation,</span>
 *  see <span class="s4">&lt;a href=&quot;https://introcs.cs.princeton.edu/15inout&quot;&gt;</span><span class="s0">Section 1.5</span><span class="s4">&lt;/a&gt; </span><span class="s0">of</span>
 *  <span class="s4">&lt;em&gt;</span><span class="s0">Computer Science: An Interdisciplinary Approach</span><span class="s4">&lt;/em&gt;</span>
 <span class="s0">*  by Robert Sedgewick and Kevin Wayne.</span>
 *
 *  <span class="s3">@author </span><span class="s0">Robert Sedgewick</span>
 *  <span class="s3">@author </span><span class="s0">Kevin Wayne</span>
 */
<span class="s2">public final class </span>StdDraw <span class="s2">implements </span>ActionListener, MouseListener, MouseMotionListener, KeyListener {

    <span class="s0">/**</span>
     *  The color black.
     */
    <span class="s2">public static final </span>Color BLACK = Color.BLACK;

    <span class="s0">/**</span>
     *  The color blue.
     */
    <span class="s2">public static final </span>Color BLUE = Color.BLUE;

    <span class="s0">/**</span>
     *  The color cyan.
     */
    <span class="s2">public static final </span>Color CYAN = Color.CYAN;

    <span class="s0">/**</span>
     *  The color dark gray.
     */
    <span class="s2">public static final </span>Color DARK_GRAY = Color.DARK_GRAY;

    <span class="s0">/**</span>
     *  The color gray.
     */
    <span class="s2">public static final </span>Color GRAY = Color.GRAY;

    <span class="s0">/**</span>
     *  The color green.
     */
    <span class="s2">public static final </span>Color GREEN  = Color.GREEN;

    <span class="s0">/**</span>
     *  The color light gray.
     */
    <span class="s2">public static final </span>Color LIGHT_GRAY = Color.LIGHT_GRAY;

    <span class="s0">/**</span>
     *  The color magenta.
     */
    <span class="s2">public static final </span>Color MAGENTA = Color.MAGENTA;

    <span class="s0">/**</span>
     *  The color orange.
     */
    <span class="s2">public static final </span>Color ORANGE = Color.ORANGE;

    <span class="s0">/**</span>
     *  The color pink.
     */
    <span class="s2">public static final </span>Color PINK = Color.PINK;

    <span class="s0">/**</span>
     *  The color red.
     */
    <span class="s2">public static final </span>Color RED = Color.RED;

    <span class="s0">/**</span>
     *  The color white.
     */
    <span class="s2">public static final </span>Color WHITE = Color.WHITE;

    <span class="s0">/**</span>
     *  The color yellow.
     */
    <span class="s2">public static final </span>Color YELLOW = Color.YELLOW;

    <span class="s0">/**</span>
     * Shade of blue used in <span class="s4">&lt;em&gt;</span><span class="s0">Introduction to Programming in Java</span><span class="s4">&lt;/em&gt;</span><span class="s0">.</span>
     * It is Pantone 300U. The RGB values are approximately (9, 90, 166).
     */
    <span class="s2">public static final </span>Color BOOK_BLUE = <span class="s2">new </span>Color(<span class="s5">9</span>, <span class="s5">90</span>, <span class="s5">166</span>);

    <span class="s0">/**</span>
     * Shade of light blue used in <span class="s4">&lt;em&gt;</span><span class="s0">Introduction to Programming in Java</span><span class="s4">&lt;/em&gt;</span><span class="s0">.</span>
     * The RGB values are approximately (103, 198, 243).
     */
    <span class="s2">public static final </span>Color BOOK_LIGHT_BLUE = <span class="s2">new </span>Color(<span class="s5">103</span>, <span class="s5">198</span>, <span class="s5">243</span>);

    <span class="s0">/**</span>
     * Shade of red used in <span class="s4">&lt;em&gt;</span><span class="s0">Algorithms, 4th edition</span><span class="s4">&lt;/em&gt;</span><span class="s0">.</span>
     * It is Pantone 1805U. The RGB values are approximately (150, 35, 31).
     */
    <span class="s2">public static final </span>Color BOOK_RED = <span class="s2">new </span>Color(<span class="s5">150</span>, <span class="s5">35</span>, <span class="s5">31</span>);

    <span class="s0">/**</span>
     * Shade of orange used in Princeton University's identity.
     * It is PMS 158. The RGB values are approximately (245, 128, 37).
     */
    <span class="s2">public static final </span>Color PRINCETON_ORANGE = <span class="s2">new </span>Color(<span class="s5">245</span>, <span class="s5">128</span>, <span class="s5">37</span>);

    <span class="s0">// default colors</span>
    <span class="s2">private static final </span>Color DEFAULT_PEN_COLOR   = BLACK;
    <span class="s2">private static final </span>Color DEFAULT_CLEAR_COLOR = WHITE;

    <span class="s0">// items pen color</span>
    <span class="s2">private static </span>Color penColor;

    <span class="s0">// default canvas size is DEFAULT_SIZE-by-DEFAULT_SIZE</span>
    <span class="s2">private static final int </span>DEFAULT_SIZE = <span class="s5">512</span>;
    <span class="s2">private static int </span>width  = DEFAULT_SIZE;
    <span class="s2">private static int </span>height = DEFAULT_SIZE;

    <span class="s0">// default pen radius</span>
    <span class="s2">private static final double </span>DEFAULT_PEN_RADIUS = <span class="s5">0.002</span>;

    <span class="s0">// items pen radius</span>
    <span class="s2">private static double </span>penRadius;

    <span class="s0">// show we draw immediately or wait until next show?</span>
    <span class="s2">private static boolean </span>defer = <span class="s2">false</span>;

    <span class="s0">// boundary of drawing canvas, 0% border</span>
    // private static final double BORDER = 0.05;
    <span class="s2">private static final double </span>BORDER = <span class="s5">0.00</span>;
    <span class="s2">private static final double </span>DEFAULT_XMIN = <span class="s5">0.0</span>;
    <span class="s2">private static final double </span>DEFAULT_XMAX = <span class="s5">1.0</span>;
    <span class="s2">private static final double </span>DEFAULT_YMIN = <span class="s5">0.0</span>;
    <span class="s2">private static final double </span>DEFAULT_YMAX = <span class="s5">1.0</span>;
    <span class="s2">private static double </span>xmin, ymin, xmax, ymax;

    <span class="s0">// for synchronization</span>
    <span class="s2">private static </span>Object mouseLock = <span class="s2">new </span>Object();
    <span class="s2">private static </span>Object keyLock = <span class="s2">new </span>Object();

    <span class="s0">// default font</span>
    <span class="s2">private static final </span>Font DEFAULT_FONT = <span class="s2">new </span>Font(<span class="s6">&quot;SansSerif&quot;</span>, Font.PLAIN, <span class="s5">16</span>);

    <span class="s0">// items font</span>
    <span class="s2">private static </span>Font font;

    <span class="s0">// double buffered graphics</span>
    <span class="s2">private static </span>BufferedImage offscreenImage, onscreenImage;
    <span class="s2">private static </span>Graphics2D offscreen, onscreen;

    <span class="s0">// singleton for callbacks: avoids generation of extra .class files</span>
    <span class="s2">private static </span>StdDraw std = <span class="s2">new </span>StdDraw();

    <span class="s0">// the frame for drawing to the screen</span>
    <span class="s2">private static </span>JFrame frame;

    <span class="s0">// mouse state</span>
    <span class="s2">private static boolean </span>isMousePressed = <span class="s2">false</span>;
    <span class="s2">private static double </span>mouseX = <span class="s5">0</span>;
    <span class="s2">private static double </span>mouseY = <span class="s5">0</span>;

    <span class="s0">// queue of typed key characters</span>
    <span class="s2">private static </span>LinkedList&lt;Character&gt; keysTyped = <span class="s2">new </span>LinkedList&lt;Character&gt;();

    <span class="s0">// set of key codes currently pressed down</span>
    <span class="s2">private static </span>TreeSet&lt;Integer&gt; keysDown = <span class="s2">new </span>TreeSet&lt;Integer&gt;();

    <span class="s0">// singleton pattern: client can't instantiate</span>
    <span class="s2">private </span>StdDraw() { }


    <span class="s0">// static initializer</span>
    <span class="s2">static </span>{
        init();
    }

    <span class="s0">/**</span>
     * Sets the canvas (drawing area) to be 512-by-512 pixels.
     * This also erases the items drawing and resets the coordinate system,
     * pen radius, pen color, and font back to their default values.
     * Ordinarly, this method is called once, at the very beginning
     * of a program.
     */
    <span class="s2">public static void </span>setCanvasSize() {
        setCanvasSize(DEFAULT_SIZE, DEFAULT_SIZE);
    }

    <span class="s0">/**</span>
     * Sets the canvas (drawing area) to be <span class="s4">&lt;em&gt;</span><span class="s0">width</span><span class="s4">&lt;/em&gt;</span><span class="s0">-by-</span><span class="s4">&lt;em&gt;</span><span class="s0">height</span><span class="s4">&lt;/em&gt; </span><span class="s0">pixels.</span>
     * This also erases the items drawing and resets the coordinate system,
     * pen radius, pen color, and font back to their default values.
     * Ordinarly, this method is called once, at the very beginning
     * of a program.
     *
     * <span class="s3">@param  </span><span class="s0">canvasWidth the width as a number of pixels</span>
     * <span class="s3">@param  </span><span class="s0">canvasHeight the height as a number of pixels</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException unless both {</span><span class="s3">@code </span><span class="s0">canvasWidth} and</span>
     *         {<span class="s3">@code </span><span class="s0">canvasHeight} are positive</span>
     */
    <span class="s2">public static void </span>setCanvasSize(<span class="s2">int </span>canvasWidth, <span class="s2">int </span>canvasHeight) {
        <span class="s2">if </span>(canvasWidth &lt;= <span class="s5">0 </span>|| canvasHeight &lt;= <span class="s5">0</span>)
            <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;width and height must be positive&quot;</span>);
        width = canvasWidth;
        height = canvasHeight;
        init();
    }

    <span class="s0">// init</span>
    <span class="s2">private static void </span>init() {
        <span class="s2">if </span>(frame != <span class="s2">null</span>) frame.setVisible(<span class="s2">false</span>);
        frame = <span class="s2">new </span>JFrame();
        offscreenImage = <span class="s2">new </span>BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        onscreenImage  = <span class="s2">new </span>BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        offscreen = offscreenImage.createGraphics();
        onscreen  = onscreenImage.createGraphics();
        setXscale();
        setYscale();
        offscreen.setColor(DEFAULT_CLEAR_COLOR);
        offscreen.fillRect(<span class="s5">0</span>, <span class="s5">0</span>, width, height);
        setPenColor();
        setPenRadius();
        setFont();
        clear();

        <span class="s0">// add antialiasing</span>
        RenderingHints hints = <span class="s2">new </span>RenderingHints(RenderingHints.KEY_ANTIALIASING,
                                                  RenderingHints.VALUE_ANTIALIAS_ON);
        hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        offscreen.addRenderingHints(hints);

        <span class="s0">// frame stuff</span>
        ImageIcon icon = <span class="s2">new </span>ImageIcon(onscreenImage);
        JLabel draw = <span class="s2">new </span>JLabel(icon);

        draw.addMouseListener(std);
        draw.addMouseMotionListener(std);

        frame.setContentPane(draw);
        frame.addKeyListener(std);    <span class="s0">// JLabel cannot get keyboard focus</span>
        frame.setResizable(<span class="s2">false</span>);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            <span class="s0">// closes all windows</span>
        // frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);      // closes only items window
        frame.setTitle(<span class="s6">&quot;Standard Draw&quot;</span>);
        frame.setJMenuBar(createMenuBar());
        frame.pack();
        frame.requestFocusInWindow();
        frame.setVisible(<span class="s2">true</span>);
    }

    <span class="s0">// create the menu bar (changed to private)</span>
    <span class="s2">private static </span>JMenuBar createMenuBar() {
        JMenuBar menuBar = <span class="s2">new </span>JMenuBar();
        JMenu menu = <span class="s2">new </span>JMenu(<span class="s6">&quot;File&quot;</span>);
        menuBar.add(menu);
        JMenuItem menuItem1 = <span class="s2">new </span>JMenuItem(<span class="s6">&quot; Save...   &quot;</span>);
        menuItem1.addActionListener(std);
        menuItem1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,
                                Toolkit.getDefaultToolkit().getMenuShortcutKeyMask()));
        menu.add(menuItem1);
        <span class="s2">return </span>menuBar;
    }


   <span class="s0">/***************************************************************************</span>
    *  User and screen coordinate systems.
    ***************************************************************************/

    /**
     * Sets the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to be the default (between 0.0 and 1.0).</span>
     */
    <span class="s2">public static void </span>setXscale() {
        setXscale(DEFAULT_XMIN, DEFAULT_XMAX);
    }

    <span class="s0">/**</span>
     * Sets the <span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to be the default (between 0.0 and 1.0).</span>
     */
    <span class="s2">public static void </span>setYscale() {
        setYscale(DEFAULT_YMIN, DEFAULT_YMAX);
    }

    <span class="s0">/**</span>
     * Sets the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to be the default</span>
     * (between 0.0 and 1.0).
     */
    <span class="s2">public static void </span>setScale() {
        setXscale();
        setYscale();
    }

    <span class="s0">/**</span>
     * Sets the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to the specified range.</span>
     *
     * <span class="s3">@param  </span><span class="s0">min the minimum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale</span>
     * <span class="s3">@param  </span><span class="s0">max the maximum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">(max == min)}</span>
     */
    <span class="s2">public static void </span>setXscale(<span class="s2">double </span>min, <span class="s2">double </span>max) {
        <span class="s2">double </span>size = max - min;
        <span class="s2">if </span>(size == <span class="s5">0.0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;the min and max are the same&quot;</span>);
        <span class="s2">synchronized </span>(mouseLock) {
            xmin = min - BORDER * size;
            xmax = max + BORDER * size;
        }
    }

    <span class="s0">/**</span>
     * Sets the <span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to the specified range.</span>
     *
     * <span class="s3">@param  </span><span class="s0">min the minimum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale</span>
     * <span class="s3">@param  </span><span class="s0">max the maximum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">(max == min)}</span>
     */
    <span class="s2">public static void </span>setYscale(<span class="s2">double </span>min, <span class="s2">double </span>max) {
        <span class="s2">double </span>size = max - min;
        <span class="s2">if </span>(size == <span class="s5">0.0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;the min and max are the same&quot;</span>);
        <span class="s2">synchronized </span>(mouseLock) {
            ymin = min - BORDER * size;
            ymax = max + BORDER * size;
        }
    }

    <span class="s0">/**</span>
     * Sets both the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scale to the (same) specified range.</span>
     *
     * <span class="s3">@param  </span><span class="s0">min the minimum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scales</span>
     * <span class="s3">@param  </span><span class="s0">max the maximum value of the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">- and </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-scales</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">(max == min)}</span>
     */
    <span class="s2">public static void </span>setScale(<span class="s2">double </span>min, <span class="s2">double </span>max) {
        <span class="s2">double </span>size = max - min;
        <span class="s2">if </span>(size == <span class="s5">0.0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;the min and max are the same&quot;</span>);
        <span class="s2">synchronized </span>(mouseLock) {
            xmin = min - BORDER * size;
            xmax = max + BORDER * size;
            ymin = min - BORDER * size;
            ymax = max + BORDER * size;
        }
    }

    <span class="s0">// helper functions that scale from user coordinates to screen coordinates and back</span>
    <span class="s2">private static double  </span>scaleX(<span class="s2">double </span>x) { <span class="s2">return </span>width  * (x - xmin) / (xmax - xmin); }
    <span class="s2">private static double  </span>scaleY(<span class="s2">double </span>y) { <span class="s2">return </span>height * (ymax - y) / (ymax - ymin); }
    <span class="s2">private static double </span>factorX(<span class="s2">double </span>w) { <span class="s2">return </span>w * width  / Math.abs(xmax - xmin);  }
    <span class="s2">private static double </span>factorY(<span class="s2">double </span>h) { <span class="s2">return </span>h * height / Math.abs(ymax - ymin);  }
    <span class="s2">private static double   </span>userX(<span class="s2">double </span>x) { <span class="s2">return </span>xmin + x * (xmax - xmin) / width;    }
    <span class="s2">private static double   </span>userY(<span class="s2">double </span>y) { <span class="s2">return </span>ymax - y * (ymax - ymin) / height;   }


    <span class="s0">/**</span>
     * Clears the screen to the default color (white).
     */
    <span class="s2">public static void </span>clear() {
        clear(DEFAULT_CLEAR_COLOR);
    }

    <span class="s0">/**</span>
     * Clears the screen to the specified color.
     *
     * <span class="s3">@param </span><span class="s0">color the color to make the background</span>
     */
    <span class="s2">public static void </span>clear(Color color) {
        offscreen.setColor(color);
        offscreen.fillRect(<span class="s5">0</span>, <span class="s5">0</span>, width, height);
        offscreen.setColor(penColor);
        draw();
    }

    <span class="s0">/**</span>
     * Returns the items pen radius.
     *
     * <span class="s3">@return </span><span class="s0">the items value of the pen radius</span>
     */
    <span class="s2">public static double </span>getPenRadius() {
        <span class="s2">return </span>penRadius;
    }

    <span class="s0">/**</span>
     * Sets the pen size to the default size (0.002).
     * The pen is circular, so that lines have rounded ends, and when you set the
     * pen radius and draw a point, you get a circle of the specified radius.
     * The pen radius is not affected by coordinate scaling.
     */
    <span class="s2">public static void </span>setPenRadius() {
        setPenRadius(DEFAULT_PEN_RADIUS);
    }

    <span class="s0">/**</span>
     * Sets the radius of the pen to the specified size.
     * The pen is circular, so that lines have rounded ends, and when you set the
     * pen radius and draw a point, you get a circle of the specified radius.
     * The pen radius is not affected by coordinate scaling.
     *
     * <span class="s3">@param  </span><span class="s0">radius the radius of the pen</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">radius} is negative</span>
     */
    <span class="s2">public static void </span>setPenRadius(<span class="s2">double </span>radius) {
        <span class="s2">if </span>(!(radius &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;pen radius must be nonnegative&quot;</span>);
        penRadius = radius;
        <span class="s2">float </span>scaledPenRadius = (<span class="s2">float</span>) (radius * DEFAULT_SIZE);
        BasicStroke stroke = <span class="s2">new </span>BasicStroke(scaledPenRadius, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);
        <span class="s0">// BasicStroke stroke = new BasicStroke(scaledPenRadius);</span>
        offscreen.setStroke(stroke);
    }

    <span class="s0">/**</span>
     * Returns the items pen color.
     *
     * <span class="s3">@return </span><span class="s0">the items pen color</span>
     */
    <span class="s2">public static </span>Color getPenColor() {
        <span class="s2">return </span>penColor;
    }

    <span class="s0">/**</span>
     * Set the pen color to the default color (black).
     */
    <span class="s2">public static void </span>setPenColor() {
        setPenColor(DEFAULT_PEN_COLOR);
    }

    <span class="s0">/**</span>
     * Sets the pen color to the specified color.
     * <span class="s4">&lt;p&gt;</span>
     <span class="s0">* The predefined pen colors are</span>
     * {<span class="s3">@code </span><span class="s0">StdDraw.BLACK}, {</span><span class="s3">@code </span><span class="s0">StdDraw.BLUE}, {</span><span class="s3">@code </span><span class="s0">StdDraw.CYAN},</span>
     * {<span class="s3">@code </span><span class="s0">StdDraw.DARK_GRAY}, {</span><span class="s3">@code </span><span class="s0">StdDraw.GRAY}, {</span><span class="s3">@code </span><span class="s0">StdDraw.GREEN},</span>
     * {<span class="s3">@code </span><span class="s0">StdDraw.LIGHT_GRAY}, {</span><span class="s3">@code </span><span class="s0">StdDraw.MAGENTA}, {</span><span class="s3">@code </span><span class="s0">StdDraw.ORANGE},</span>
     * {<span class="s3">@code </span><span class="s0">StdDraw.PINK}, {</span><span class="s3">@code </span><span class="s0">StdDraw.RED}, {</span><span class="s3">@code </span><span class="s0">StdDraw.WHITE}, and</span>
     * {<span class="s3">@code </span><span class="s0">StdDraw.YELLOW}.</span>
     *
     * <span class="s3">@param </span><span class="s0">color the color to make the pen</span>
     */
    <span class="s2">public static void </span>setPenColor(Color color) {
        <span class="s2">if </span>(color == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        penColor = color;
        offscreen.setColor(penColor);
    }

    <span class="s0">/**</span>
     * Sets the pen color to the specified RGB color.
     *
     * <span class="s3">@param  </span><span class="s0">red the amount of red (between 0 and 255)</span>
     * <span class="s3">@param  </span><span class="s0">green the amount of green (between 0 and 255)</span>
     * <span class="s3">@param  </span><span class="s0">blue the amount of blue (between 0 and 255)</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">red}, {</span><span class="s3">@code </span><span class="s0">green},</span>
     *         or {<span class="s3">@code </span><span class="s0">blue} is outside its prescribed range</span>
     */
    <span class="s2">public static void </span>setPenColor(<span class="s2">int </span>red, <span class="s2">int </span>green, <span class="s2">int </span>blue) {
        <span class="s2">if </span>(red   &lt; <span class="s5">0 </span>|| red   &gt;= <span class="s5">256</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;amount of red must be between 0 and 255&quot;</span>);
        <span class="s2">if </span>(green &lt; <span class="s5">0 </span>|| green &gt;= <span class="s5">256</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;amount of green must be between 0 and 255&quot;</span>);
        <span class="s2">if </span>(blue  &lt; <span class="s5">0 </span>|| blue  &gt;= <span class="s5">256</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;amount of blue must be between 0 and 255&quot;</span>);
        setPenColor(<span class="s2">new </span>Color(red, green, blue));
    }

    <span class="s0">/**</span>
     * Returns the items font.
     *
     * <span class="s3">@return </span><span class="s0">the items font</span>
     */
    <span class="s2">public static </span>Font getFont() {
        <span class="s2">return </span>font;
    }

    <span class="s0">/**</span>
     * Sets the font to the default font (sans serif, 16 point).
     */
    <span class="s2">public static void </span>setFont() {
        setFont(DEFAULT_FONT);
    }

    <span class="s0">/**</span>
     * Sets the font to the specified value.
     *
     * <span class="s3">@param </span><span class="s0">font the font</span>
     */
    <span class="s2">public static void </span>setFont(Font font) {
        <span class="s2">if </span>(font == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        StdDraw.font = font;
    }


   <span class="s0">/***************************************************************************</span>
    *  Drawing geometric shapes.
    ***************************************************************************/

    /**
     * Draws a line segment between (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">) and</span>
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x0 the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of one endpoint</span>
     * <span class="s3">@param  </span><span class="s0">y0 the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of one endpoint</span>
     * <span class="s3">@param  </span><span class="s0">x1 the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the other endpoint</span>
     * <span class="s3">@param  </span><span class="s0">y1 the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the other endpoint</span>
     */
    <span class="s2">public static void </span>line(<span class="s2">double </span>x0, <span class="s2">double </span>y0, <span class="s2">double </span>x1, <span class="s2">double </span>y1) {
        offscreen.draw(<span class="s2">new </span>Line2D.Double(scaleX(x0), scaleY(y0), scaleX(x1), scaleY(y1)));
        draw();
    }

    <span class="s0">/**</span>
     * Draws one pixel at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     * This method is private because pixels depend on the display.
     * To achieve the same effect, set the pen radius to 0 and call {<span class="s3">@code </span><span class="s0">point()}.</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the pixel</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the pixel</span>
     */
    <span class="s2">private static void </span>pixel(<span class="s2">double </span>x, <span class="s2">double </span>y) {
        offscreen.fillRect((<span class="s2">int</span>) Math.round(scaleX(x)), (<span class="s2">int</span>) Math.round(scaleY(y)), <span class="s5">1</span>, <span class="s5">1</span>);
    }

    <span class="s0">/**</span>
     * Draws a point centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     * The point is a filled circle whose radius is equal to the pen radius.
     * To draw a single-pixel point, first set the pen radius to 0.
     *
     * <span class="s3">@param </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the point</span>
     * <span class="s3">@param </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the point</span>
     */
    <span class="s2">public static void </span>point(<span class="s2">double </span>x, <span class="s2">double </span>y) {
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>r = penRadius;
        <span class="s2">float </span>scaledPenRadius = (<span class="s2">float</span>) (r * DEFAULT_SIZE);

        <span class="s0">// double ws = factorX(2*r);</span>
        // double hs = factorY(2*r);
        // if (ws &lt;= 1 &amp;&amp; hs &lt;= 1) pixel(x, y);
        <span class="s2">if </span>(scaledPenRadius &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.fill(<span class="s2">new </span>Ellipse2D.Double(xs - scaledPenRadius/<span class="s5">2</span>, ys - scaledPenRadius/<span class="s5">2</span>,
                                                 scaledPenRadius, scaledPenRadius));
        draw();
    }

    <span class="s0">/**</span>
     * Draws a circle of the specified radius, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">radius the radius of the circle</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">radius} is negative</span>
     */
    <span class="s2">public static void </span>circle(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>radius) {
        <span class="s2">if </span>(!(radius &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;radius must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*radius);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*radius);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.draw(<span class="s2">new </span>Ellipse2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }

    <span class="s0">/**</span>
     * Draws a filled circle of the specified radius, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">radius the radius of the circle</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">radius} is negative</span>
     */
    <span class="s2">public static void </span>filledCircle(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>radius) {
        <span class="s2">if </span>(!(radius &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;radius must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*radius);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*radius);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.fill(<span class="s2">new </span>Ellipse2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }


    <span class="s0">/**</span>
     * Draws an ellipse with the specified semimajor and semiminor axes,
     * centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">semiMajorAxis is the semimajor axis of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">semiMinorAxis is the semiminor axis of the ellipse</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">semiMajorAxis}</span>
     *         or {<span class="s3">@code </span><span class="s0">semiMinorAxis} is negative</span>
     */
    <span class="s2">public static void </span>ellipse(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>semiMajorAxis, <span class="s2">double </span>semiMinorAxis) {
        <span class="s2">if </span>(!(semiMajorAxis &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;ellipse semimajor axis must be nonnegative&quot;</span>);
        <span class="s2">if </span>(!(semiMinorAxis &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;ellipse semiminor axis must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*semiMajorAxis);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*semiMinorAxis);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.draw(<span class="s2">new </span>Ellipse2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }

    <span class="s0">/**</span>
     * Draws an ellipse with the specified semimajor and semiminor axes,
     * centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">semiMajorAxis is the semimajor axis of the ellipse</span>
     * <span class="s3">@param  </span><span class="s0">semiMinorAxis is the semiminor axis of the ellipse</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">semiMajorAxis}</span>
     *         or {<span class="s3">@code </span><span class="s0">semiMinorAxis} is negative</span>
     */
    <span class="s2">public static void </span>filledEllipse(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>semiMajorAxis, <span class="s2">double </span>semiMinorAxis) {
        <span class="s2">if </span>(!(semiMajorAxis &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;ellipse semimajor axis must be nonnegative&quot;</span>);
        <span class="s2">if </span>(!(semiMinorAxis &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;ellipse semiminor axis must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*semiMajorAxis);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*semiMinorAxis);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.fill(<span class="s2">new </span>Ellipse2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }


    <span class="s0">/**</span>
     * Draws a circular arc of the specified radius,
     * centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">), from angle1 to angle2 (in degrees).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the circle</span>
     * <span class="s3">@param  </span><span class="s0">radius the radius of the circle</span>
     * <span class="s3">@param  </span><span class="s0">angle1 the starting angle. 0 would mean an arc beginning at 3 o'clock.</span>
     * <span class="s3">@param  </span><span class="s0">angle2 the angle at the end of the arc. For example, if</span>
     *         you want a 90 degree arc, then angle2 should be angle1 + 90.
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">radius} is negative</span>
     */
    <span class="s2">public static void </span>arc(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>radius, <span class="s2">double </span>angle1, <span class="s2">double </span>angle2) {
        <span class="s2">if </span>(radius &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;arc radius must be nonnegative&quot;</span>);
        <span class="s2">while </span>(angle2 &lt; angle1) angle2 += <span class="s5">360</span>;
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*radius);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*radius);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.draw(<span class="s2">new </span>Arc2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs, angle1, angle2 - angle1, Arc2D.OPEN));
        draw();
    }

    <span class="s0">/**</span>
     * Draws a square of side length 2r, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the square</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the square</span>
     * <span class="s3">@param  </span><span class="s0">halfLength one half the length of any side of the square</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">halfLength} is negative</span>
     */
    <span class="s2">public static void </span>square(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>halfLength) {
        <span class="s2">if </span>(!(halfLength &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half length must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*halfLength);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*halfLength);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.draw(<span class="s2">new </span>Rectangle2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }

    <span class="s0">/**</span>
     * Draws a filled square of the specified size, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the square</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the square</span>
     * <span class="s3">@param  </span><span class="s0">halfLength one half the length of any side of the square</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if {</span><span class="s3">@code </span><span class="s0">halfLength} is negative</span>
     */
    <span class="s2">public static void </span>filledSquare(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>halfLength) {
        <span class="s2">if </span>(!(halfLength &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half length must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*halfLength);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*halfLength);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.fill(<span class="s2">new </span>Rectangle2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }


    <span class="s0">/**</span>
     * Draws a rectangle of the specified size, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">halfWidth one half the width of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">halfHeight one half the height of the rectangle</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">halfWidth} or {</span><span class="s3">@code </span><span class="s0">halfHeight} is negative</span>
     */
    <span class="s2">public static void </span>rectangle(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>halfWidth, <span class="s2">double </span>halfHeight) {
        <span class="s2">if </span>(!(halfWidth  &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half width must be nonnegative&quot;</span>);
        <span class="s2">if </span>(!(halfHeight &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half height must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*halfWidth);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*halfHeight);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.draw(<span class="s2">new </span>Rectangle2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }

    <span class="s0">/**</span>
     * Draws a filled rectangle of the specified size, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the center of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">halfWidth one half the width of the rectangle</span>
     * <span class="s3">@param  </span><span class="s0">halfHeight one half the height of the rectangle</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">halfWidth} or {</span><span class="s3">@code </span><span class="s0">halfHeight} is negative</span>
     */
    <span class="s2">public static void </span>filledRectangle(<span class="s2">double </span>x, <span class="s2">double </span>y, <span class="s2">double </span>halfWidth, <span class="s2">double </span>halfHeight) {
        <span class="s2">if </span>(!(halfWidth  &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half width must be nonnegative&quot;</span>);
        <span class="s2">if </span>(!(halfHeight &gt;= <span class="s5">0</span>)) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;half height must be nonnegative&quot;</span>);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(<span class="s5">2</span>*halfWidth);
        <span class="s2">double </span>hs = factorY(<span class="s5">2</span>*halfHeight);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>offscreen.fill(<span class="s2">new </span>Rectangle2D.Double(xs - ws/<span class="s5">2</span>, ys - hs/<span class="s5">2</span>, ws, hs));
        draw();
    }


    <span class="s0">/**</span>
     * Draws a polygon with the vertices 
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">),</span>
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">), ...,</span>
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;&lt;em&gt;</span><span class="s0">n</span><span class="s4">&lt;/em&gt;</span><span class="s0">–1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;&lt;em&gt;</span><span class="s0">n</span><span class="s4">&lt;/em&gt;</span><span class="s0">–1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x an array of all the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates of the polygon</span>
     * <span class="s3">@param  </span><span class="s0">y an array of all the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates of the polygon</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException unless {</span><span class="s3">@code </span><span class="s0">x[]} and {</span><span class="s3">@code </span><span class="s0">y[]}</span>
     *         are of the same length
     */
    <span class="s2">public static void </span>polygon(<span class="s2">double</span>[] x, <span class="s2">double</span>[] y) {
        <span class="s2">if </span>(x == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;x-coordinate array is null&quot;</span>);
        <span class="s2">if </span>(y == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;y-coordinate array is null&quot;</span>);
        <span class="s2">int </span>n1 = x.length;
        <span class="s2">int </span>n2 = y.length;
        <span class="s2">if </span>(n1 != n2) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;arrays must be of the same length&quot;</span>);
        <span class="s2">int </span>n = n1;
        <span class="s2">if </span>(n == <span class="s5">0</span>) <span class="s2">return</span>;

        GeneralPath path = <span class="s2">new </span>GeneralPath();
        path.moveTo((<span class="s2">float</span>) scaleX(x[<span class="s5">0</span>]), (<span class="s2">float</span>) scaleY(y[<span class="s5">0</span>]));
        <span class="s2">for </span>(<span class="s2">int </span>i = <span class="s5">0</span>; i &lt; n; i++)
            path.lineTo((<span class="s2">float</span>) scaleX(x[i]), (<span class="s2">float</span>) scaleY(y[i]));
        path.closePath();
        offscreen.draw(path);
        draw();
    }

    <span class="s0">/**</span>
     * Draws a polygon with the vertices 
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">0</span><span class="s4">&lt;/sub&gt;</span><span class="s0">),</span>
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;</span><span class="s0">1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">), ...,</span>
     * (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;&lt;sub&gt;&lt;em&gt;</span><span class="s0">n</span><span class="s4">&lt;/em&gt;</span><span class="s0">–1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;&lt;sub&gt;&lt;em&gt;</span><span class="s0">n</span><span class="s4">&lt;/em&gt;</span><span class="s0">–1</span><span class="s4">&lt;/sub&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x an array of all the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates of the polygon</span>
     * <span class="s3">@param  </span><span class="s0">y an array of all the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinates of the polygon</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException unless {</span><span class="s3">@code </span><span class="s0">x[]} and {</span><span class="s3">@code </span><span class="s0">y[]}</span>
     *         are of the same length
     */
    <span class="s2">public static void </span>filledPolygon(<span class="s2">double</span>[] x, <span class="s2">double</span>[] y) {
        <span class="s2">if </span>(x == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;x-coordinate array is null&quot;</span>);
        <span class="s2">if </span>(y == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;y-coordinate array is null&quot;</span>);
        <span class="s2">int </span>n1 = x.length;
        <span class="s2">int </span>n2 = y.length;
        <span class="s2">if </span>(n1 != n2) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;arrays must be of the same length&quot;</span>);
        <span class="s2">int </span>n = n1;
        <span class="s2">if </span>(n == <span class="s5">0</span>) <span class="s2">return</span>;

        GeneralPath path = <span class="s2">new </span>GeneralPath();
        path.moveTo((<span class="s2">float</span>) scaleX(x[<span class="s5">0</span>]), (<span class="s2">float</span>) scaleY(y[<span class="s5">0</span>]));
        <span class="s2">for </span>(<span class="s2">int </span>i = <span class="s5">0</span>; i &lt; n; i++)
            path.lineTo((<span class="s2">float</span>) scaleX(x[i]), (<span class="s2">float</span>) scaleY(y[i]));
        path.closePath();
        offscreen.fill(path);
        draw();
    }


   <span class="s0">/***************************************************************************</span>
    *  Drawing images.
    ***************************************************************************/
    // get an image from the given filename
    <span class="s2">private static </span>Image getImage(String filename) {
        <span class="s2">if </span>(filename == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();

        <span class="s0">// to read from file</span>
        ImageIcon icon = <span class="s2">new </span>ImageIcon(filename);

        <span class="s0">// try to read from URL</span>
        <span class="s2">if </span>((icon == <span class="s2">null</span>) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
            <span class="s2">try </span>{
                URL url = <span class="s2">new </span>URL(filename);
                icon = <span class="s2">new </span>ImageIcon(url);
            }
            <span class="s2">catch </span>(MalformedURLException e) {
                <span class="s0">/* not a url */</span>
            }
        }

        <span class="s0">// in case file is inside a .jar (classpath relative to StdDraw)</span>
        <span class="s2">if </span>((icon == <span class="s2">null</span>) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
            URL url = StdDraw.<span class="s2">class</span>.getResource(filename);
            <span class="s2">if </span>(url != <span class="s2">null</span>)
                icon = <span class="s2">new </span>ImageIcon(url);
        }

        <span class="s0">// in case file is inside a .jar (classpath relative to root of jar)</span>
        <span class="s2">if </span>((icon == <span class="s2">null</span>) || (icon.getImageLoadStatus() != MediaTracker.COMPLETE)) {
            URL url = StdDraw.<span class="s2">class</span>.getResource(<span class="s6">&quot;/&quot; </span>+ filename);
            <span class="s2">if </span>(url == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;image &quot; </span>+ filename + <span class="s6">&quot; not found&quot;</span>);
            icon = <span class="s2">new </span>ImageIcon(url);
        }

        <span class="s2">return </span>icon.getImage();
    }

   <span class="s0">/***************************************************************************</span>
    * [Summer 2016] Should we update to use ImageIO instead of ImageIcon()?
    *               Seems to have some issues loading images on some systems
    *               and slows things down on other systems.
    *               especially if you don't call ImageIO.setUseCache(false)
    *               One advantage is that it returns a BufferedImage.
    ***************************************************************************/
/* 
    private static BufferedImage getImage(String filename) { 
        if (filename == null) throw new IllegalArgumentException(); 
 
        // from a file or URL 
        try { 
            URL url = new URL(filename); 
            BufferedImage image = ImageIO.read(url); 
            return image; 
        }  
        catch (IOException e) { 
            // ignore 
        } 
 
        // in case file is inside a .jar (classpath relative to StdDraw) 
        try { 
            URL url = StdDraw.class.getResource(filename); 
            BufferedImage image = ImageIO.read(url); 
            return image; 
        }  
        catch (IOException e) { 
            // ignore 
        } 
 
        // in case file is inside a .jar (classpath relative to root of jar) 
        try { 
            URL url = StdDraw.class.getResource(&quot;/&quot; + filename); 
            BufferedImage image = ImageIO.read(url); 
            return image; 
        }  
        catch (IOException e) { 
            // ignore 
        } 
        throw new IllegalArgumentException(&quot;image &quot; + filename + &quot; not found&quot;); 
    } 
*/
    /**
     * Draws the specified image centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     * The supported image formats are JPEG, PNG, and GIF.
     * As an optimization, the picture is cached, so there is no performance
     * penalty for redrawing the same image multiple times (e.g., in an animation).
     * However, if you change the picture file after drawing it, subsequent
     * calls will draw the original picture.
     *
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">filename the name of the image/picture, e.g., &quot;ball.gif&quot;</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if the image filename is invalid</span>
     */
    <span class="s2">public static void </span>picture(<span class="s2">double </span>x, <span class="s2">double </span>y, String filename) {
        <span class="s0">// BufferedImage image = getImage(filename);</span>
        Image image = getImage(filename);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s0">// int ws = image.getWidth();    // can call only if image is a BufferedImage</span>
        // int hs = image.getHeight();
        <span class="s2">int </span>ws = image.getWidth(<span class="s2">null</span>);
        <span class="s2">int </span>hs = image.getHeight(<span class="s2">null</span>);
        <span class="s2">if </span>(ws &lt; <span class="s5">0 </span>|| hs &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;image &quot; </span>+ filename + <span class="s6">&quot; is corrupt&quot;</span>);

        offscreen.drawImage(image, (<span class="s2">int</span>) Math.round(xs - ws/<span class="s5">2.0</span>), (<span class="s2">int</span>) Math.round(ys - hs/<span class="s5">2.0</span>), <span class="s2">null</span>);
        draw();
    }

    <span class="s0">/**</span>
     * Draws the specified image centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">),</span>
     * rotated given number of degrees.
     * The supported image formats are JPEG, PNG, and GIF.
     *
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">filename the name of the image/picture, e.g., &quot;ball.gif&quot;</span>
     * <span class="s3">@param  </span><span class="s0">degrees is the number of degrees to rotate counterclockwise</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if the image filename is invalid</span>
     */
    <span class="s2">public static void </span>picture(<span class="s2">double </span>x, <span class="s2">double </span>y, String filename, <span class="s2">double </span>degrees) {
        <span class="s0">// BufferedImage image = getImage(filename);</span>
        Image image = getImage(filename);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s0">// int ws = image.getWidth();    // can call only if image is a BufferedImage</span>
        // int hs = image.getHeight();
        <span class="s2">int </span>ws = image.getWidth(<span class="s2">null</span>);
        <span class="s2">int </span>hs = image.getHeight(<span class="s2">null</span>);
        <span class="s2">if </span>(ws &lt; <span class="s5">0 </span>|| hs &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;image &quot; </span>+ filename + <span class="s6">&quot; is corrupt&quot;</span>);

        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
        offscreen.drawImage(image, (<span class="s2">int</span>) Math.round(xs - ws/<span class="s5">2.0</span>), (<span class="s2">int</span>) Math.round(ys - hs/<span class="s5">2.0</span>), <span class="s2">null</span>);
        offscreen.rotate(Math.toRadians(+degrees), xs, ys);

        draw();
    }

    <span class="s0">/**</span>
     * Draws the specified image centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">),</span>
     * rescaled to the specified bounding box.
     * The supported image formats are JPEG, PNG, and GIF.
     *
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">filename the name of the image/picture, e.g., &quot;ball.gif&quot;</span>
     * <span class="s3">@param  </span><span class="s0">scaledWidth the width of the scaled image (in screen coordinates)</span>
     * <span class="s3">@param  </span><span class="s0">scaledHeight the height of the scaled image (in screen coordinates)</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">scaledWidth}</span>
     *         or {<span class="s3">@code </span><span class="s0">scaledHeight} is negative</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if the image filename is invalid</span>
     */
    <span class="s2">public static void </span>picture(<span class="s2">double </span>x, <span class="s2">double </span>y, String filename, <span class="s2">double </span>scaledWidth, <span class="s2">double </span>scaledHeight) {
        Image image = getImage(filename);
        <span class="s2">if </span>(scaledWidth  &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;width  is negative: &quot; </span>+ scaledWidth);
        <span class="s2">if </span>(scaledHeight &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;height is negative: &quot; </span>+ scaledHeight);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(scaledWidth);
        <span class="s2">double </span>hs = factorY(scaledHeight);
        <span class="s2">if </span>(ws &lt; <span class="s5">0 </span>|| hs &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;image &quot; </span>+ filename + <span class="s6">&quot; is corrupt&quot;</span>);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);
        <span class="s2">else </span>{
            offscreen.drawImage(image, (<span class="s2">int</span>) Math.round(xs - ws/<span class="s5">2.0</span>),
                                       (<span class="s2">int</span>) Math.round(ys - hs/<span class="s5">2.0</span>),
                                       (<span class="s2">int</span>) Math.round(ws),
                                       (<span class="s2">int</span>) Math.round(hs), <span class="s2">null</span>);
        }
        draw();
    }


    <span class="s0">/**</span>
     * Draws the specified image centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">), rotated</span>
     * given number of degrees, and rescaled to the specified bounding box.
     * The supported image formats are JPEG, PNG, and GIF.
     *
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the image</span>
     * <span class="s3">@param  </span><span class="s0">filename the name of the image/picture, e.g., &quot;ball.gif&quot;</span>
     * <span class="s3">@param  </span><span class="s0">scaledWidth the width of the scaled image (in screen coordinates)</span>
     * <span class="s3">@param  </span><span class="s0">scaledHeight the height of the scaled image (in screen coordinates)</span>
     * <span class="s3">@param  </span><span class="s0">degrees is the number of degrees to rotate counterclockwise</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if either {</span><span class="s3">@code </span><span class="s0">scaledWidth}</span>
     *         or {<span class="s3">@code </span><span class="s0">scaledHeight} is negative</span>
     * <span class="s3">@throws </span><span class="s0">IllegalArgumentException if the image filename is invalid</span>
     */
    <span class="s2">public static void </span>picture(<span class="s2">double </span>x, <span class="s2">double </span>y, String filename, <span class="s2">double </span>scaledWidth, <span class="s2">double </span>scaledHeight, <span class="s2">double </span>degrees) {
        <span class="s2">if </span>(scaledWidth &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;width is negative: &quot; </span>+ scaledWidth);
        <span class="s2">if </span>(scaledHeight &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;height is negative: &quot; </span>+ scaledHeight);
        Image image = getImage(filename);
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">double </span>ws = factorX(scaledWidth);
        <span class="s2">double </span>hs = factorY(scaledHeight);
        <span class="s2">if </span>(ws &lt; <span class="s5">0 </span>|| hs &lt; <span class="s5">0</span>) <span class="s2">throw new </span>IllegalArgumentException(<span class="s6">&quot;image &quot; </span>+ filename + <span class="s6">&quot; is corrupt&quot;</span>);
        <span class="s2">if </span>(ws &lt;= <span class="s5">1 </span>&amp;&amp; hs &lt;= <span class="s5">1</span>) pixel(x, y);

        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
        offscreen.drawImage(image, (<span class="s2">int</span>) Math.round(xs - ws/<span class="s5">2.0</span>),
                                   (<span class="s2">int</span>) Math.round(ys - hs/<span class="s5">2.0</span>),
                                   (<span class="s2">int</span>) Math.round(ws),
                                   (<span class="s2">int</span>) Math.round(hs), <span class="s2">null</span>);
        offscreen.rotate(Math.toRadians(+degrees), xs, ys);

        draw();
    }

   <span class="s0">/***************************************************************************</span>
    *  Drawing text.
    ***************************************************************************/

    /**
     * Write the given text string in the items font, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">text the text to write</span>
     */
    <span class="s2">public static void </span>text(<span class="s2">double </span>x, <span class="s2">double </span>y, String text) {
        <span class="s2">if </span>(text == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        offscreen.setFont(font);
        FontMetrics metrics = offscreen.getFontMetrics();
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">int </span>ws = metrics.stringWidth(text);
        <span class="s2">int </span>hs = metrics.getDescent();
        offscreen.drawString(text, (<span class="s2">float</span>) (xs - ws/<span class="s5">2.0</span>), (<span class="s2">float</span>) (ys + hs));
        draw();
    }

    <span class="s0">/**</span>
     * Write the given text string in the items font, centered at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">) and</span>
     * rotated by the specified number of degrees.
     * <span class="s3">@param  </span><span class="s0">x the center </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">y the center </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">text the text to write</span>
     * <span class="s3">@param  </span><span class="s0">degrees is the number of degrees to rotate counterclockwise</span>
     */
    <span class="s2">public static void </span>text(<span class="s2">double </span>x, <span class="s2">double </span>y, String text, <span class="s2">double </span>degrees) {
        <span class="s2">if </span>(text == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        offscreen.rotate(Math.toRadians(-degrees), xs, ys);
        text(x, y, text);
        offscreen.rotate(Math.toRadians(+degrees), xs, ys);
    }


    <span class="s0">/**</span>
     * Write the given text string in the items font, left-aligned at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">text the text</span>
     */
    <span class="s2">public static void </span>textLeft(<span class="s2">double </span>x, <span class="s2">double </span>y, String text) {
        <span class="s2">if </span>(text == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        offscreen.setFont(font);
        FontMetrics metrics = offscreen.getFontMetrics();
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">int </span>hs = metrics.getDescent();
        offscreen.drawString(text, (<span class="s2">float</span>) xs, (<span class="s2">float</span>) (ys + hs));
        draw();
    }

    <span class="s0">/**</span>
     * Write the given text string in the items font, right-aligned at (<span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">, </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">).</span>
     *
     * <span class="s3">@param  </span><span class="s0">x the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">y the </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the text</span>
     * <span class="s3">@param  </span><span class="s0">text the text to write</span>
     */
    <span class="s2">public static void </span>textRight(<span class="s2">double </span>x, <span class="s2">double </span>y, String text) {
        <span class="s2">if </span>(text == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        offscreen.setFont(font);
        FontMetrics metrics = offscreen.getFontMetrics();
        <span class="s2">double </span>xs = scaleX(x);
        <span class="s2">double </span>ys = scaleY(y);
        <span class="s2">int </span>ws = metrics.stringWidth(text);
        <span class="s2">int </span>hs = metrics.getDescent();
        offscreen.drawString(text, (<span class="s2">float</span>) (xs - ws), (<span class="s2">float</span>) (ys + hs));
        draw();
    }



    <span class="s0">/**</span>
     * Copies the offscreen buffer to the onscreen buffer, pauses for t milliseconds
     * and enables double buffering.
     * <span class="s3">@param </span><span class="s0">t number of milliseconds</span>
     * <span class="s3">@deprecated </span><span class="s0">replaced by {</span><span class="s3">@link </span><span class="s0">#enableDoubleBuffering()}, {</span><span class="s3">@link </span><span class="s0">#show()}, and {</span><span class="s3">@link </span><span class="s0">#pause(int t)}</span>
     */
    @Deprecated
    <span class="s2">public static void </span>show(<span class="s2">int </span>t) {
        show();
        pause(t);
        enableDoubleBuffering();
    }

    <span class="s0">/**</span>
     * Pause for t milliseconds. This method is intended to support computer animations.
     * <span class="s3">@param </span><span class="s0">t number of milliseconds</span>
     */
    <span class="s2">public static void </span>pause(<span class="s2">int </span>t) {
        <span class="s2">try </span>{
            Thread.sleep(t);
        }
        <span class="s2">catch </span>(InterruptedException e) {
            System.out.println(<span class="s6">&quot;Error sleeping&quot;</span>);
        }
    }

    <span class="s0">/**</span>
     * Copies offscreen buffer to onscreen buffer. There is no reason to call
     * this method unless double buffering is enabled.
     */
    <span class="s2">public static void </span>show() {
        onscreen.drawImage(offscreenImage, <span class="s5">0</span>, <span class="s5">0</span>, <span class="s2">null</span>);
        frame.repaint();
    }

    <span class="s0">// draw onscreen if defer is false</span>
    <span class="s2">private static void </span>draw() {
        <span class="s2">if </span>(!defer) show();
    }

    <span class="s0">/**</span>
     * Enable double buffering. All subsequent calls to 
     * drawing methods such as {<span class="s3">@code </span><span class="s0">line()}, {</span><span class="s3">@code </span><span class="s0">circle()},</span>
     * and {<span class="s3">@code </span><span class="s0">square()} will be deffered until the next call</span>
     * to show(). Useful for animations.
     */
    <span class="s2">public static void </span>enableDoubleBuffering() {
        defer = <span class="s2">true</span>;
    }

    <span class="s0">/**</span>
     * Disable double buffering. All subsequent calls to 
     * drawing methods such as {<span class="s3">@code </span><span class="s0">line()}, {</span><span class="s3">@code </span><span class="s0">circle()},</span>
     * and {<span class="s3">@code </span><span class="s0">square()} will be displayed on screen when called.</span>
     * This is the default.
     */
    <span class="s2">public static void </span>disableDoubleBuffering() {
        defer = <span class="s2">false</span>;
    }


   <span class="s0">/***************************************************************************</span>
    *  Save drawing to a file.
    ***************************************************************************/

    /**
     * Saves the drawing to using the specified filename.
     * The supported image formats are JPEG and PNG;
     * the filename suffix must be {<span class="s3">@code </span><span class="s0">.jpg} or {</span><span class="s3">@code </span><span class="s0">.png}.</span>
     *
     * <span class="s3">@param  </span><span class="s0">filename the name of the file with one of the required suffixes</span>
     */
    <span class="s2">public static void </span>save(String filename) {
        <span class="s2">if </span>(filename == <span class="s2">null</span>) <span class="s2">throw new </span>IllegalArgumentException();
        File file = <span class="s2">new </span>File(filename);
        String suffix = filename.substring(filename.lastIndexOf(<span class="s6">'.'</span>) + <span class="s5">1</span>);

        <span class="s0">// png files</span>
        <span class="s2">if </span>(<span class="s6">&quot;png&quot;</span>.equalsIgnoreCase(suffix)) {
            <span class="s2">try </span>{
                ImageIO.write(onscreenImage, suffix, file);
            }
            <span class="s2">catch </span>(IOException e) {
                e.printStackTrace();
            }
        }

        <span class="s0">// need to change from ARGB to RGB for JPEG</span>
        // reference: http://archives.java.sun.com/cgi-bin/wa?A2=ind0404&amp;L=java2d-interest&amp;D=0&amp;P=2727
        <span class="s2">else if </span>(<span class="s6">&quot;jpg&quot;</span>.equalsIgnoreCase(suffix)) {
            WritableRaster raster = onscreenImage.getRaster();
            WritableRaster newRaster;
            newRaster = raster.createWritableChild(<span class="s5">0</span>, <span class="s5">0</span>, width, height, <span class="s5">0</span>, <span class="s5">0</span>, <span class="s2">new int</span>[] {<span class="s5">0</span>, <span class="s5">1</span>, <span class="s5">2</span>});
            DirectColorModel cm = (DirectColorModel) onscreenImage.getColorModel();
            DirectColorModel newCM = <span class="s2">new </span>DirectColorModel(cm.getPixelSize(),
                                                          cm.getRedMask(),
                                                          cm.getGreenMask(),
                                                          cm.getBlueMask());
            BufferedImage rgbBuffer = <span class="s2">new </span>BufferedImage(newCM, newRaster, <span class="s2">false</span>,  <span class="s2">null</span>);
            <span class="s2">try </span>{
                ImageIO.write(rgbBuffer, suffix, file);
            }
            <span class="s2">catch </span>(IOException e) {
                e.printStackTrace();
            }
        }

        <span class="s2">else </span>{
            System.out.println(<span class="s6">&quot;Invalid image file type: &quot; </span>+ suffix);
        }
    }


    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>actionPerformed(ActionEvent e) {
        FileDialog chooser = <span class="s2">new </span>FileDialog(StdDraw.frame, <span class="s6">&quot;Use a .png or .jpg extension&quot;</span>, FileDialog.SAVE);
        chooser.setVisible(<span class="s2">true</span>);
        String filename = chooser.getFile();
        <span class="s2">if </span>(filename != <span class="s2">null</span>) {
            StdDraw.save(chooser.getDirectory() + File.separator + chooser.getFile());
        }
    }


   <span class="s0">/***************************************************************************</span>
    *  Mouse interactions.
    ***************************************************************************/

    /**
     * Returns true if the mouse is being pressed.
     *
     * <span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if the mouse is being pressed; {</span><span class="s3">@code </span><span class="s0">false} otherwise</span>
     */
    <span class="s2">public static boolean </span>isMousePressed() {
        <span class="s2">synchronized </span>(mouseLock) {
            <span class="s2">return </span>isMousePressed;
        }
    }

    <span class="s0">/**</span>
     * Returns true if the mouse is being pressed.
     *
     * <span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if the mouse is being pressed; {</span><span class="s3">@code </span><span class="s0">false} otherwise</span>
     * <span class="s3">@deprecated </span><span class="s0">replaced by {</span><span class="s3">@link </span><span class="s0">#isMousePressed()}</span>
     */
    @Deprecated
    <span class="s2">public static boolean </span>mousePressed() {
        <span class="s2">synchronized </span>(mouseLock) {
            <span class="s2">return </span>isMousePressed;
        }
    }

    <span class="s0">/**</span>
     * Returns the <span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the mouse.</span>
     *
     * <span class="s3">@return </span><span class="s0">the </span><span class="s4">&lt;em&gt;</span><span class="s0">x</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the mouse</span>
     */
    <span class="s2">public static double </span>mouseX() {
        <span class="s2">synchronized </span>(mouseLock) {
            <span class="s2">return </span>mouseX;
        }
    }

    <span class="s0">/**</span>
     * Returns the <span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the mouse.</span>
     *
     * <span class="s3">@return </span><span class="s4">&lt;em&gt;</span><span class="s0">y</span><span class="s4">&lt;/em&gt;</span><span class="s0">-coordinate of the mouse</span>
     */
    <span class="s2">public static double </span>mouseY() {
        <span class="s2">synchronized </span>(mouseLock) {
            <span class="s2">return </span>mouseY;
        }
    }


    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseClicked(MouseEvent e) {
        <span class="s0">// this body is intentionally left empty</span>
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseEntered(MouseEvent e) {
        <span class="s0">// this body is intentionally left empty</span>
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseExited(MouseEvent e) {
        <span class="s0">// this body is intentionally left empty</span>
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mousePressed(MouseEvent e) {
        <span class="s2">synchronized </span>(mouseLock) {
            mouseX = StdDraw.userX(e.getX());
            mouseY = StdDraw.userY(e.getY());
            isMousePressed = <span class="s2">true</span>;
        }
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseReleased(MouseEvent e) {
        <span class="s2">synchronized </span>(mouseLock) {
            isMousePressed = <span class="s2">false</span>;
        }
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseDragged(MouseEvent e)  {
        <span class="s2">synchronized </span>(mouseLock) {
            mouseX = StdDraw.userX(e.getX());
            mouseY = StdDraw.userY(e.getY());
        }
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>mouseMoved(MouseEvent e) {
        <span class="s2">synchronized </span>(mouseLock) {
            mouseX = StdDraw.userX(e.getX());
            mouseY = StdDraw.userY(e.getY());
        }
    }


   <span class="s0">/***************************************************************************</span>
    *  Keyboard interactions.
    ***************************************************************************/

    /**
     * Returns true if the user has typed a key (that has not yet been processed).
     *
     * <span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if the user has typed a key (that has not yet been processed</span>
     *         by {<span class="s3">@link </span><span class="s0">#nextKeyTyped()}; {</span><span class="s3">@code </span><span class="s0">false} otherwise</span>
     */
    <span class="s2">public static boolean </span>hasNextKeyTyped() {
        <span class="s2">synchronized </span>(keyLock) {
            <span class="s2">return </span>!keysTyped.isEmpty();
        }
    }

    <span class="s0">/**</span>
     * Returns the next key that was typed by the user (that your program has not already processed).
     * This method should be preceded by a call to {<span class="s3">@link </span><span class="s0">#hasNextKeyTyped()} to ensure</span>
     * that there is a next key to process.
     * This method returns a Unicode character corresponding to the key
     * typed (such as {<span class="s3">@code </span><span class="s0">'a'} or {</span><span class="s3">@code </span><span class="s0">'A'}).</span>
     * It cannot identify action steps (such as F1 and arrow steps)
     * or modifier steps (such as control).
     *
     * <span class="s3">@return </span><span class="s0">the next key typed by the user (that your program has not already processed).</span>
     * <span class="s3">@throws </span><span class="s0">NoSuchElementException if there is no remaining key</span>
     */
    <span class="s2">public static char </span>nextKeyTyped() {
        <span class="s2">synchronized </span>(keyLock) {
            <span class="s2">if </span>(keysTyped.isEmpty()) {
                <span class="s2">throw new </span>NoSuchElementException(<span class="s6">&quot;your program has already processed all keystrokes&quot;</span>);
            }
            <span class="s2">return </span>keysTyped.remove(keysTyped.size() - <span class="s5">1</span>);
            <span class="s0">// return keysTyped.removeLast();</span>
        }
    }

    <span class="s0">/**</span>
     * Returns true if the given key is being pressed.
     * <span class="s4">&lt;p&gt;</span>
     <span class="s0">* This method takes the keycode (corresponding to a physical key)</span>
    *  as an argument. It can handle action steps
     * (such as F1 and arrow steps) and modifier steps (such as shift and control).
     * See {<span class="s3">@link </span><span class="s0">KeyEvent} for a description of key codes.</span>
     *
     * <span class="s3">@param  </span><span class="s0">keycode the key to check if it is being pressed</span>
     * <span class="s3">@return </span><span class="s0">{</span><span class="s3">@code </span><span class="s0">true} if {</span><span class="s3">@code </span><span class="s0">keycode} is currently being pressed;</span>
     *         {<span class="s3">@code </span><span class="s0">false} otherwise</span>
     */
    <span class="s2">public static boolean </span>isKeyPressed(<span class="s2">int </span>keycode) {
        <span class="s2">synchronized </span>(keyLock) {
            <span class="s2">return </span>keysDown.contains(keycode);
        }
    }


    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>keyTyped(KeyEvent e) {
        <span class="s2">synchronized </span>(keyLock) {
            keysTyped.addFirst(e.getKeyChar());
        }
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>keyPressed(KeyEvent e) {
        <span class="s2">synchronized </span>(keyLock) {
            keysDown.add(e.getKeyCode());
        }
    }

    <span class="s0">/**</span>
     * This method cannot be called directly.
     */
    @Override
    <span class="s2">public void </span>keyReleased(KeyEvent e) {
        <span class="s2">synchronized </span>(keyLock) {
            keysDown.remove(e.getKeyCode());
        }
    }




    <span class="s0">/**</span>
     * Test client.
     *
     * <span class="s3">@param </span><span class="s0">args the command-line arguments</span>
     */
    <span class="s2">public static void </span>main(String[] args) {
        StdDraw.square(<span class="s5">0.2</span>, <span class="s5">0.8</span>, <span class="s5">0.1</span>);
        StdDraw.filledSquare(<span class="s5">0.8</span>, <span class="s5">0.8</span>, <span class="s5">0.2</span>);
        StdDraw.circle(<span class="s5">0.8</span>, <span class="s5">0.2</span>, <span class="s5">0.2</span>);

        StdDraw.setPenColor(StdDraw.BOOK_RED);
        StdDraw.setPenRadius(<span class="s5">0.02</span>);
        StdDraw.arc(<span class="s5">0.8</span>, <span class="s5">0.2</span>, <span class="s5">0.1</span>, <span class="s5">200</span>, <span class="s5">45</span>);

        <span class="s0">// draw a blue diamond</span>
        StdDraw.setPenRadius();
        StdDraw.setPenColor(StdDraw.BOOK_BLUE);
        <span class="s2">double</span>[] x = { <span class="s5">0.1</span>, <span class="s5">0.2</span>, <span class="s5">0.3</span>, <span class="s5">0.2 </span>};
        <span class="s2">double</span>[] y = { <span class="s5">0.2</span>, <span class="s5">0.3</span>, <span class="s5">0.2</span>, <span class="s5">0.1 </span>};
        StdDraw.filledPolygon(x, y);

        <span class="s0">// text</span>
        StdDraw.setPenColor(StdDraw.BLACK);
        StdDraw.text(<span class="s5">0.2</span>, <span class="s5">0.5</span>, <span class="s6">&quot;black text&quot;</span>);
        StdDraw.setPenColor(StdDraw.WHITE);
        StdDraw.text(<span class="s5">0.8</span>, <span class="s5">0.8</span>, <span class="s6">&quot;white text&quot;</span>);
    }

}
</pre>
</body>
</html>